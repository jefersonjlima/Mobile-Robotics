\documentclass[aspectratio=169]{beamer}
\usetheme{simple}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{lmodern}
\usepackage{ragged2e}
\usefonttheme[onlymath]{serif} 
\usepackage[scale=2]{ccicons} 
% \setbeamertemplate{caption}[numbered]
\usepackage{copyrightbox}
\DeclareMathOperator*{\argmin}{arg\,min}


\usepackage{graphicx,hyperref,url,pgfplots}
\usepackage{amsmath} 
\usepackage{array,booktabs}
\pgfplotsset{compat=1.13}
\usepackage{bibentry}
\usepackage[alf,abnt-etal-list=0,abnt-etal-cite=2]{abntex2cite}
\usepackage[normalem]{ulem}
\PassOptionsToPackage{demo}{graphicx}
\def\HiLi{\leavevmode\rlap{\hbox to \hsize{\color{yellow!50}\leaders\hrule height .8\baselineskip depth .5ex\hfill}}}

\usepackage[
    type={CC},
    modifier={by-nc-sa},
    version={4.0},
]{doclicense}

\setbeamercovered{invisible} 
\newcommand{\df}[1]{\,\mathrm{d}#1}
\newcommand{\parcial}[3]{\dfrac{\partial^{#1}#2}{\partial #3^{#1}}}
\newcommand{\cpright}[2]{\copyrightbox[b]{#1}{\tiny Source: #2}}
%Tikz
\newcommand{\tikzRot}{0}
\newcommand{\tikzTrans}{(0,0)}
\newcommand{\tikzShowrobot}{0}
\newcommand{\tikzOneCenter}{0}



\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{xcolor}
\usetikzlibrary{scopes}
\usepackage{verbatim}
\usetikzlibrary{patterns}
\usepackage{algorithm}
\usepackage{algpseudocode}
\def\NoNumber#1{{\def\alglinenumber##1{}\State #1}\addtocounter{ALG@line}{-1}}

\usepackage{listings}
  \lstdefinestyle{ascii-tree}{
    literate={├}{|}1 {─}{--}1 {└}{+}1 
  }
	\definecolor{codegreen}{rgb}{0,0.6,0}
	\definecolor{codegray}{rgb}{0.5,0.5,0.5}
	\definecolor{codepurple}{rgb}{0.58,0,0.82}
	\definecolor{backcolour}{rgb}{0.92,0.92,0.92}
	\lstset{language=Python, 
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\fontsize{8}{11}\ttfamily,
	frame=lines,
%	numbers=left,
	tabsize=2,
	morekeywords={models, lambda, forms},
	showstringspaces=false}

\usepackage{catchfile}
\newcommand{\getenv}[2][]{%
	\CatchFileEdef{\temp}{"|kpsewhich --var-value #2"}{\endlinechar=-1}%
	\if\relax\detokenize{#1}\relax\temp\else\let#1\temp\fi}

\getenv[\BIBREF]{RM_REFERENCES}


% --------------------------------------------------------------------------------------------

\title{Mobile Robots}
\subtitle{Pose Estimation - ICP Algorithm}
\date{\today}
\author[Jeferson José de Lima]{
  \textbf{Professor}: Jeferson José de Lima}
\institute{Academic Department of Informatics (DAINF) \\ Federal University of Technology - Paraná (UTFPR) at Pato Branco, PR, Brazil}

\begin{document}
\maketitle
\justify

\begin{frame}{Useful Information}

	\begin{block}{License}
        \doclicenseThis
    \end{block}

	\begin{block}{links:}
		\begin{enumerate}
			\item \href{https://gitlab.com/cursoseaulas/robotica-movel/-/wikis/home}{Mobile Robots - Gitlab Page}
			\item \BIBREF
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}{Pose Estimation}
	\framesubtitle{}
	After this lesson, you will able to:
	\begin{itemize}
		\item Describe the point LiDAR points and how it can be used for state estimation
		\item Implement the Iterative Closest Point (ICP) algorithm. 
	\end{itemize}
\end{frame}

 
\begin{frame}{Pose Estimation}
	\framesubtitle{Point Clouds}

	\textcolor{purple}{\textbf{Point Cloud}} 

	\begin{itemize}
		\item A point cloud is a set of data points in space. The points represent a 3D shape or object. Each point has its set of $X$, $Y$ and $Z$ coordinates.\footnote[frame]{\textcolor{blue}{\textbf{More info}}: \href{https://www.zivid.com/3d-point-cloud-examples/}{3D Cloud Point Examples}}
	\end{itemize}

	\addtolength{\jot}{5em}
	\begin{align*}
		\cpright{\includegraphics[width=0.45\textwidth]{./images/pcexample1.png}}
		{https://www.zivid.com/3d-point-cloud-examples/} & &
		\cpright{\includegraphics[width=0.45\textwidth]{./images/pcexample2.png}}
		{https://www.geospatialworld.net/news/} 
	\end{align*}
		

\end{frame}


\begin{frame}{Pose Estimation}
	\framesubtitle{\textcolor{purple}{What motion of the car best aligns the two point clouds?}}
		
    \begin{columns}
        \begin{column}[c]{0.5\textwidth}
            \input{./images/car_1icp_image.tex}
        \end{column}
        \begin{column}[c]{0.5\textwidth}
			\vspace{0.4in}
            \input{./images/car_2icp_image.tex}
        \end{column}
    \end{columns}

	\vspace{0.1in}

	\begin{block}{\textcolor{blue}{We just need to solve for the transformation $\textcolor{gray}{\mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})}$:}}

	\begin{equation*}
        \begin{bmatrix}
            \color{blue}{ \mathbf{P}_{t+1}} \\ 1
        \end{bmatrix}
        =
        \left[
            \begin{matrix}
                  & \color{brown}{\mathbf{R}_z(\theta)} &   \\ \hline
                0 & 0 & 0 \\
            \end{matrix} \right.
            \left.
            \vline
            \begin{matrix}
                \color{purple}{\mathbf{Q}} \\ \hline
                1
            \end{matrix} \right]
        \begin{bmatrix}
            \color{red}{\mathbf{P}_{t}} \\
            1
        \end{bmatrix}
		\text{, or }
		\begin{bmatrix}
            \color{blue}{ \mathbf{P}_{t+1}} \\ 1
        \end{bmatrix}
        =
        \mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})
        \begin{bmatrix}
            \color{red}{\mathbf{P}_{t}} \\
            1
        \end{bmatrix}
    \end{equation*}
\end{block}
\end{frame}

\begin{frame}{Pose Estimation}
	\framesubtitle{2D LiDAR Data Example}

	\textbf{Turtlebot3 and 2D LiDAR Data}:

	\begin{figure}
		\includegraphics[width=1\textwidth]{./images/lidarExample.png}
	\end{figure}
\end{frame}


\begin{frame}{Pose Estimation}
	\framesubtitle{2D LiDAR Data Example}

	\textbf{Velodyne 3D LiDAR Sensor}:

	\begin{figure}
		\cpright{\includegraphics[width=0.6\textwidth]{./images/velodyne_sensor.png}}
		{\cite{wang2015fast}}
		\caption{Point cloud of the Velodyne LiDAR.}
	\end{figure}
\end{frame} 
 
\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\begin{block}{}
		\textcolor{red}{\textbf{Problem}: We don’t know which points correspond to each other}
	\end{block}

	\vspace{0.3in}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

    \begin{itemize}
        \item \textbf{Intuition}: When the optimal motion is found, corresponding points will be closer to each other than to other points
        \item  \textbf{Heuristic}: For each point, the best candidate for a corresponding point is the point that is closest to it right now
    \end{itemize}

\end{minipage}
\begin{minipage}{0.4\textwidth}
	\begin{figure}
		\renewcommand{\tikzRot}{40}
		\renewcommand{\tikzTrans}{(6,0)}
		\renewcommand{\tikzShowrobot}{1}
		\resizebox{0.8\textwidth}{!}{
		\input{./images/cloudpoints_image.tex}}
	\end{figure}
\end{minipage}
\end{frame}


\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

	\begin{algorithm}[H]
		\renewcommand{\thealgorithm}{}
        \caption{ICP Algorithm}
        \begin{algorithmic}
		\Procedure{Initialization}{$\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$}
			\State{\HiLi$\mathbf{c}^{t}, \mathbf{c}^{t+1} \gets \text{Centre for }
			 (\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}})$} \Comment{$\mathbf{c} = [x_c, y_c]$}
			 \State{$\textcolor{red}{\mathbf{P}_{t}} = \mathbf{T}(0, d(\mathbf{c}^k)) \cdot \textcolor{red}{\mathbf{P}_{t+1}}$}
		\EndProcedure
		\While{$\mathbf{\hat{r}}(\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}) > E_{\text{min}}\text{ or } N > N_{\text{max}}$}
			\State{Associate($\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$)} \Comment{KNN Algorithm}
			\State{Solve Optimal $\mathbf{T}(\theta, \mathbf{Q})$} \Comment{Least-Squares}
		\EndWhile
        \end{algorithmic}
    \end{algorithm}

\end{minipage}
\begin{minipage}{0.4\textwidth}
	\begin{figure}
		\resizebox{0.8\textwidth}{!}{
			\renewcommand{\tikzRot}{40}
			\renewcommand{\tikzTrans}{(6,0)}
			\renewcommand{\tikzShowrobot}{0}
			\resizebox{0.8\textwidth}{!}{
			\input{./images/cloudpoints_image.tex}}
		}
	\end{figure}
\end{minipage}
\end{frame}

\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

	\begin{algorithm}[H]
		\renewcommand{\thealgorithm}{}
        \caption{ICP Algorithm}
        \begin{algorithmic}
		\Procedure{Initialization}{$\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$}
			\State{$\mathbf{s}^{t}, \mathbf{s}^{t+1} \gets \text{Centre for }
			(\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}})$} \Comment{$\mathbf{s}^{+} = [x_c^k, y_c^k]$}
			\State{\HiLi$\textcolor{red}{\mathbf{P}_{t}} = \mathbf{T}(0, \text{diff}(\mathbf{s}^{+})) \cdot \textcolor{red}{\mathbf{P}_{t+1}}$}
		\EndProcedure
		\While{$d(\mathbf{T}(\theta, \mathbf{Q})) > E_{\text{max}}\text{ or } N > N_{\text{max}}$}
			\State{Associate($\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$)} \Comment{KNN Algorithm}
			\State{Solve Optimal $\mathbf{T}(\theta, \mathbf{Q})$} \Comment{Least-Squares}
			\State{$N++$}
		\EndWhile
		\State{\textbf{Return} $\mathbf{T}(\theta, \mathbf{Q})$}
	\end{algorithmic}
    \end{algorithm}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
		\begin{figure}
			\resizebox{0.75\textwidth}{!}{
				\renewcommand{\tikzRot}{40}
				\renewcommand{\tikzTrans}{(0,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{1}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
			}
		\end{figure}
	\end{minipage}
\end{frame}

\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

	\begin{algorithm}[H]
		\renewcommand{\thealgorithm}{}
        \caption{ICP Algorithm}
        \begin{algorithmic}
		\Procedure{Initialization}{$\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$}
			\State{$\mathbf{s}^{t}, \mathbf{s}^{t+1} \gets \text{Centre for }
			(\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}})$} \Comment{$\mathbf{s}^{+} = [x_c^k, y_c^k]$}
			\State $\textcolor{red}{\mathbf{P}_{t}} = \mathbf{T}(0, \text{diff}(\mathbf{s}^{+})) \cdot \textcolor{red}{\mathbf{P}_{t+1}}$
		\EndProcedure
		\While{$d(\mathbf{T}(\theta, \mathbf{Q})) > E_{\text{max}}\text{ or } N > N_{\text{max}}$}
			\State{\HiLi Associate($\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$)} \Comment{KNN Algorithm}
			\State{\HiLi Solve Optimal $\mathbf{T}(\theta, \mathbf{Q})$} \Comment{Least-Squares}
			\State{$N++$}
		\EndWhile
		\State{\textbf{Return} $\mathbf{T}(\theta, \mathbf{Q})$}        \end{algorithmic}
    \end{algorithm}

\end{minipage}
\begin{minipage}{0.4\textwidth}
		\begin{figure}
			\resizebox{0.7\textwidth}{!}{
				\renewcommand{\tikzRot}{20}
				\renewcommand{\tikzTrans}{(0,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{1}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
			}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

	\begin{algorithm}[H]
		\renewcommand{\thealgorithm}{}
        \caption{ICP Algorithm}
        \begin{algorithmic}
		\Procedure{Initialization}{$\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$}
			\State{$\mathbf{s}^{t}, \mathbf{s}^{t+1} \gets \text{Centre for }
			(\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}})$} \Comment{$\mathbf{s}^{+} = [x_c^k, y_c^k]$}
			\State $\textcolor{red}{\mathbf{P}_{t}} = \mathbf{T}(0, \text{diff}(\mathbf{s}^{+})) \cdot \textcolor{red}{\mathbf{P}_{t+1}}$
		\EndProcedure
		\While{$d(\mathbf{T}(\theta, \mathbf{Q})) > E_{\text{max}}\text{ or } N > N_{\text{max}}$}
			\State{\HiLi Associate($\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$)} \Comment{KNN Algorithm}
			\State{\HiLi Solve Optimal $\mathbf{T}(\theta, \mathbf{Q})$} \Comment{Least-Squares}
			\State{$N++$}
		\EndWhile
		\State{\textbf{Return} $\mathbf{T}(\theta, \mathbf{Q})$}
        \end{algorithmic}
    \end{algorithm}

\end{minipage}
\begin{minipage}{0.4\textwidth}
		\begin{figure}
			\resizebox{0.6\textwidth}{!}{
				\renewcommand{\tikzRot}{5}
				\renewcommand{\tikzTrans}{(0,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{1}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
			}
		\end{figure}
	\end{minipage}
\end{frame}

\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{The Iterative Closest Point (ICP) Algorithm}
	\begin{minipage}{0.6\textwidth}

	\textcolor{purple}{\textbf{The Iterative Closest Point (ICP) Algorithm}}

	\begin{algorithm}[H]
		\renewcommand{\thealgorithm}{}
        \caption{ICP Algorithm}
        \begin{algorithmic}
		\Procedure{Initialization}{$\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$}
			\State{$\mathbf{s}^{t}, \mathbf{s}^{t+1} \gets \text{Centre for }
			(\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}})$} \Comment{$\mathbf{s}^{+} = [x_c^k, y_c^k]$}
			\State $\textcolor{red}{\mathbf{P}_{t}} = \mathbf{T}(0, \text{diff}(\mathbf{s}^{+})) \cdot \textcolor{red}{\mathbf{P}_{t+1}}$
		\EndProcedure
		\While{$d(\mathbf{T}(\theta, \mathbf{Q})) > E_{\text{max}}\text{ or } N > N_{\text{max}}$}
			\State{Associate($\textcolor{red}{\mathbf{P}_{t}},\textcolor{blue}{\mathbf{P}_{t+1}}$)} \Comment{KNN Algorithm}
			\State{Solve Optimal $\mathbf{T}(\theta, \mathbf{Q})$} \Comment{IRLS}
			\State{$N++$}
		\EndWhile
		\State{\HiLi\textbf{Return} $\mathbf{T}(\theta, \mathbf{Q})$}
        \end{algorithmic}
    \end{algorithm}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
			\begin{figure}
				\resizebox{0.6\textwidth}{!}{
				\renewcommand{\tikzRot}{0.5}
				\renewcommand{\tikzTrans}{(0,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{1}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
				}
		\end{figure}
	\end{minipage}
\end{frame}


\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{ICP - Associate}

	\textbf{k-nearest neighbors algorithm}

\end{frame}


\begin{frame}[fragile, c]{Pose Estimation}
	\framesubtitle{ICP - Solve Optimal $\mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})$}
	\textbf{Iteratively Reweighted Least Squares}

	\begin{minipage}[t]{0.5\textwidth}
		\begin{figure}
			\resizebox{0.7\textwidth}{!}{
				\renewcommand{\tikzRot}{30}
				\renewcommand{\tikzTrans}{(8,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{0}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
			}
		\end{figure}
	\end{minipage}
	\begin{minipage}[t]{0.5\textwidth}

	\vspace{-0.2in}
	\begin{itemize}
		\item For \textbf{ICP Algorithm} suppose that corresponding points are the nearest ones \cite{prochazkova2018notes}.

	\vspace{-0.2in}
	\begin{equation}
		\argmin\limits_{\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}} \sum\limits_{i=1}^n w_i \lVert \textcolor{blue}{\mathbf{P}_{t+1}}
		- \mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})
		\textcolor{red}{\mathbf{P}_{t}} \rVert^2_2
		\label{eq:min}
	\end{equation}

	\item[-] Assume $w_i = 1$, we can rewhite the equation \ref{eq:min}:

	\vspace{-0.2in}
	\begin{equation*}
		\argmin\limits_{\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}} \sum\limits_{i=1}^n  
		\lVert (\textcolor{brown}{\mathbf{R}}\textcolor{red}{\mathbf{P}_{t}}  + \textcolor{purple}{\mathbf{Q}})
		-  \textcolor{blue}{\mathbf{P}_{t+1}}\rVert^2_2
	\end{equation*}

	\item[-] The $\mathbf{\hat{r}}(\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}})$ is the residual error function.
	
	\vspace{-0.2in}
	\begin{equation*}
		\mathbf{\hat{r}}(\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}) = 
		\lVert (\textcolor{brown}{\mathbf{R}}\textcolor{red}{\mathbf{P}_{t}}  + \textcolor{purple}{\mathbf{Q}})
		-  \textcolor{blue}{\mathbf{P}_{t+1}} \rVert ^2_2
	\end{equation*}

	\end{itemize}
	\end{minipage}
\end{frame}



\begin{frame}[fragile, c]{Pose Estimation}
	\framesubtitle{ICP - Solve Optimal $\mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})$}
	\textbf{Iteratively Reweighted Least Squares}

	\begin{minipage}[t]{0.5\textwidth}
		\begin{figure}
			\resizebox{0.7\textwidth}{!}{
				\renewcommand{\tikzRot}{30}
				\renewcommand{\tikzTrans}{(8,0)}
				\renewcommand{\tikzShowrobot}{0}
				\renewcommand{\tikzOneCenter}{0}
				\resizebox{0.8\textwidth}{!}{
				\input{./images/cloudpoints_image.tex}}
			}
		\end{figure}
	\end{minipage}
	\begin{minipage}[t]{0.5\textwidth}

	\vspace{-0.2in}
	\begin{itemize}
		\item The optimization step (\textit{find} ($\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}$)) is based on Singular Value Decomposition (SVD) and we need centroid $\mathbf{c}^k$ alignment.

	\vspace{-0.2in}
	\begin{equation*}
		\mathbf{c}^{t+1} = \frac{1}{N}\sum\limits_{i=0}^N \textcolor{blue}{p^{t+1}_i}, 
		\quad
		\mathbf{c}^{t} = \frac{1}{N}\sum\limits_{i=0}^N \textcolor{red}{p^{t}_i}
	\end{equation*}

	\item[-] Subsequently, we align all of the points of $\textcolor{red}{\mathbf{P}_{t}}$ and $\textcolor{blue}{\mathbf{P}_{t+1}}$, using corresponding centroid and we get:

	\vspace{-0.2in}
	\begin{equation*}
		\textcolor{red}{\mathcal{P}_{t}} = \textcolor{red}{\mathbf{P}_{t}} - \mathbf{c}^{t}, \quad \textcolor{red}{\mathcal{P}_{t}} = \textcolor{blue}{\mathbf{P}_{t+1}} - \mathbf{c}^{t+1}
	\end{equation*}

	\end{itemize}
	\end{minipage}
\end{frame}


\begin{frame}[fragile, c]{Pose Estimation}
	\framesubtitle{ICP - Solve Optimal $\mathbf{T}(\textcolor{brown}{\theta}, \textcolor{purple}{\mathbf{Q}})$}
	\textbf{Iteratively Reweighted Least Squares}

	\begin{minipage}[t]{0.5\textwidth}
			\begin{figure}
				\resizebox{0.7\textwidth}{!}{
					\renewcommand{\tikzRot}{30}
					\renewcommand{\tikzTrans}{(8,0)}
					\renewcommand{\tikzShowrobot}{0}
					\renewcommand{\tikzOneCenter}{0}
					\resizebox{0.8\textwidth}{!}{
					\input{./images/cloudpoints_image.tex}}
				}
		\end{figure}
	\end{minipage}
	\begin{minipage}[t]{0.5\textwidth}

	\vspace{-0.2in}
	\begin{itemize}
		\item[-] For these values, it is easy to compute covariance matrix $\mathbf{H} = \textcolor{blue}{\mathcal{P}_{t}} \cdot \textcolor{red}{\mathcal{P}_{t}}^T $ and make the SVD as:

	\vspace{-0.2in}
	\begin{equation*}
		\mathbf{H} = \mathbf{U \Sigma V^T}
	\end{equation*}

	\item[-] The matrix of rotation is given by:

	\vspace{-0.2in}
	\begin{equation*}
		\textcolor{brown}{\mathbf{R}} = \mathbf{V U}^T
	\end{equation*}

	\item[-] and vector of translation can be computed by:

	\vspace{-0.2in}
	\begin{equation*}
		\textcolor{purple}{\mathbf{Q}} = {\mathbf{c}_{t}} - \textcolor{brown}{\mathbf{R}} {\mathbf{c}_{t}}
	\end{equation*}

	\item Repeat until $\mathbf{\hat{r}}(\textcolor{brown}{\mathbf{R}}, \textcolor{purple}{\mathbf{Q}}) > E_{min}$

	\end{itemize}
	\end{minipage}
\end{frame}


\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{Random Sample Consensus (RANSAC)}
	\begin{minipage}[t]{0.5\textwidth}

		\begin{itemize}
			\item RANSAC (Random Sample Consensus) is a simple algorithm for robust fitting of models
			in the presence of many data outliers \cite{nuchter20083d}.
		\end{itemize}
	\end{minipage}
	\begin{minipage}[t]{0.5\textwidth}
		\begin{figure}
			\def\angle{5} % Angle of the inclined plane
			\def\desl{(8,1)}
			\resizebox{0.8\textwidth}{!}{
	% \def\angle{20} % Angle of the inclined plane
	% \def\desl{(5,1)}
			\begin{tikzpicture}
				\begin{scope}
					\node [fill=blue, draw=black, shape=circle] (0) at (-1.5, 4.5) {};
					\node [fill=blue, draw=black, shape=circle] (1) at (-0.75, 4.5) {};
					\node [fill=blue, draw=black, shape=circle] (2) at (0.5, 4.5) {};
					\node [fill=blue, draw=black, shape=circle] (3) at (1.5, 4.5) {};
					\node [fill=blue, draw=black, shape=circle] (4) at (2.5, 4.5) {};
					\node [fill=blue, draw=black, shape=circle] (5) at (-2, 4.75) {};
					\node [fill=blue, draw=black, shape=circle] (6) at (-2, 6) {};
					\node [fill=blue, draw=black, shape=circle] (7) at (2.25, -5.5) {};
					\node [fill=blue, draw=black, shape=circle] (8) at (2.25, -4.5) {};
					\node [fill=blue, draw=black, shape=circle] (9) at (2.75, -4) {};
					\node [fill=blue, draw=black, shape=circle] (10) at (4, -3.75) {};
					\node [fill=blue, draw=black, shape=circle] (12) at (5.5, -1.5) {};
					\node [fill=blue, draw=black, shape=circle] (13) at (5.5, -0.5) {};
					\node [fill=blue, draw=black, shape=circle] (14) at (5.5, -2.75) {};
					\node [fill=blue, draw=black, shape=circle] (15) at (5.25, -3.5) {};
				\end{scope}
				\begin{scope}[rotate=\angle, shift={\desl}]
					\node [fill=red, draw=black, shape=circle] (out1) at (-5, 9) {};
					\node [fill=red, draw=black, shape=circle] (out2) at (-3, 8) {};
					\node [fill=red, draw=black, shape=circle] (b0) at (-1.5, 4.5) {};
					\node [fill=red, draw=black, shape=circle] (b1) at (-0.75, 4.5) {};
					\node [fill=red, draw=black, shape=circle] (b2) at (0.5, 4.5) {};
					\node [fill=red, draw=black, shape=circle] (b3) at (1.5, 4.5) {};
					\node [fill=red, draw=black, shape=circle] (b4) at (2.5, 4.5) {};
					\node [fill=red, draw=black, shape=circle] (b5) at (-2, 4.75) {};
					\node [fill=red, draw=black, shape=circle] (b6) at (-2, 6) {};
					\node [fill=red, draw=black, shape=circle] (b7) at (2.25, -5.5) {};
					\node [fill=red, draw=black, shape=circle] (b8) at (2.25, -4.5) {};
					\node [fill=red, draw=black, shape=circle] (b9) at (2.75, -4) {};
					\node [fill=red, draw=black, shape=circle] (b10) at (4, -3.75) {};
					\node [fill=red, draw=black, shape=circle] (b12) at (5.5, -1.5) {};
					\node [fill=red, draw=black, shape=circle] (b13) at (5.5, -0.5) {};
					\node [fill=red, draw=black, shape=circle] (b14) at (5.5, -2.75) {};
					\node [fill=red, draw=black, shape=circle] (b15) at (5.25, -3.5) {};
				\end{scope}

				\pause

				\draw[green, dashed] (1) -- (b1){}; \draw[green, dashed] (2) -- (b2){};
				\draw[green, dashed] (3) -- (b3){}; \draw[green, dashed] (4) -- (b4){};
				\draw[green, dashed] (6) -- (b6){}; \draw[green, dashed] (13) -- (b13){};
				\draw[green, dashed] (5) -- (b5){}; \draw[green, dashed] (8) -- (b8){};
				\draw[green, dashed] (7) -- (b7){}; \draw[green, dashed] (10) -- (b10){}; 
				\draw[green, dashed] (9) -- (b9){}; \draw[green, dashed] (12) -- (b12){};
				\draw[green,dashed] (14) -- (b14){}; \draw[green,dashed] (15) -- (b15){};
				\draw[red, dashed] (6) -- (out1){}; \draw[red, dashed] (6) -- (out2){};
				
			\end{tikzpicture}}
		\end{figure}
	\end{minipage}
\end{frame}



\begin{frame}[fragile, t]{Pose Estimation}
	\framesubtitle{ICP - Toolbox}

	\textbf{PCD, PLY files - Tools}
	\begin{itemize}
		\item \textcolor{purple}{\textbf{PCL (Point Cloud Library)}} is an open-source framework for n-dimensional point clouds and 3D geometry processing. It includes several variants of the ICP algorithm.[9]
		\item \textcolor{purple}{\textbf{libpointmatcher}} is an implementation of point-to-point and point-to-plane ICP released under a BSD license.
		\item \textcolor{purple}{\textbf{simpleICP}} is an implementation of a rather simple version of the ICP algorithm in various languages.
		\item \textcolor{purple}{\textbf{Open3D}} is an open-source library that supports rapid development of software that deals with 3D data. 
		\item \textcolor{purple}{\textbf{PythonRobotics}} a Python code collection of robotics algorithms.
	\end{itemize}

\end{frame}

 
\begin{frame}[t, allowframebreaks]
	\frametitle{Referências}
	\bibliography{\BIBREF}
\end{frame}


\end{document}